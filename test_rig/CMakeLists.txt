cmake_minimum_required(VERSION 3.27)

FIND_PACKAGE(Java COMPONENTS Runtime Development REQUIRED)

find_package(tiny-process-library CONFIG REQUIRED)

add_executable(test_rig test_rig_main.cpp)
target_link_libraries(test_rig PRIVATE tiny-process-library::tiny-process-library)

find_path(INIPP_INCLUDE_DIRS "inipp.h")
target_include_directories(test_rig PRIVATE ${INIPP_INCLUDE_DIRS})

# Things can get confusing here between all the different java commands and
# references to the ANTLR4_JAR_LOCATION.  Here's an overview of them:
#
# CMD_ANTLR4_GENERATE_JAVA
#
#       This command runs ANTLR4 jar file as a program to generate .java files.
#
#       This uses java.exe and the -jar option with ANTLR4_JAR_LOCATION,
#       instead of classpath, because it does not need to load any classes
#       apart from that jar.  It does not need to specify the class to load
#       from the ANTLR4 jar, because the Main class is loaded automatically.
#       The commands generate Lang*.java files from the Lang*.g4 files.
#
# CMD_COMPILE_PARSER
#
#       This command links to the ANTLR4 jar file in its capacity as a library.
#
#       This uses javac.exe (compiler not runtime) to compile the Lang*.java
#       files into Lang*.class files.  It has to use -cp not -jar because both
#       the ANTLR4 jar and the build directory are needed to find classes.
#       On Windows this uses ";" but we have escape it, "\;" to prevent CMake
#       interpreting the character as a list separator, and then we have to
#       escape it AGAIN, "\\\;" because the first level gets stripped somehow.
#       On non-Windows platforms, the classpath separator is just ":".
#
# TEST_RIG_INI_*
#
#       This command (ultimately executed by a command sent from test_rig.exe)
#       runs a _different_ main in the ANTLR4 jar to test the grammar.
#
#       These are a group of CMake variables used to build up the settings file,
#       test_rig.ini.  The test_rig.exe program will read test_rig.ini to get
#       the values to build a command line that runs java.exe to actually run
#       the ANTLR4 test rig on the generated parser class.  test_rig.cpp also passes
#       a -cp option for classpath because, like the compilation, it needs to
#       reference both the ANTLR4 jar and classes in the build directory.  Unlike
#       the step for CMD_COMPILE_PARSER, file(WRITE) doesn't convert the semicolons
#       to spaces, so on Windows we can just write the classpath as list directly.
#       However on non-Windows platforms it has to convert ";" to ":".


# In the top level CMakeLists.txt, the function antlr4_generate() is used to
# generate C++ code for the lexer and parser, but the ANTLR4 TestRig requires
# a Java class to load, not a C++ file.  So we must first generate Java code
# for the parser and then compile it.  This command does the generation.
set(CMD_ANTLR4_GENERATE_JAVA
   ${Java_JAVA_EXECUTABLE}
      -jar ${ANTLR4_JAR_LOCATION}
      -o ${CMAKE_CURRENT_BINARY_DIR}
        -no-listener
        -no-visitor
)

# There is a potential for the .tokens file generated by the following custom
# command to conflict with the .tokens file generated by antlr4_generate().
# (You do not want two different build rules responsible for the same artifact.)
# That's averted here by "test_rig/" being a subdirectory of the project.

add_custom_command(
        COMMAND ${CMD_ANTLR4_GENERATE_JAVA} ${PROJECT_SOURCE_DIR}/${my_grammar}Lexer.g4
        DEPENDS ${PROJECT_SOURCE_DIR}/${my_grammar}Lexer.g4
        OUTPUT
            ${my_grammar}Lexer.java
            ${my_grammar}Lexer.tokens
        COMMENT "Running ANTLR4 (Java) to generate ${my_grammar}Lexer.java."
)

# Although _compiling_ the parser depends on both FooLexer.java and FooParser.java,
# generating the parser depends only on the lexer .tokens file (and FooParser.g4).
add_custom_command(
    COMMAND
        ${CMD_ANTLR4_GENERATE_JAVA} ${PROJECT_SOURCE_DIR}/${my_grammar}Parser.g4
    DEPENDS
            ${my_grammar}Lexer.tokens
            ${PROJECT_SOURCE_DIR}/${my_grammar}Parser.g4
        OUTPUT ${my_grammar}Parser.java
        COMMENT "Running ANTLR4 (Java) to generate ${my_grammar}Parser.java."
)

# This is used for both test_rig.ini and args to javac.
# It starts out as a list, but gets converted to string.
set(CLASSPATH_LIST
        ${ANTLR4_JAR_LOCATION}
        ${CMAKE_CURRENT_BINARY_DIR}
)

# Generate CMake variable, COMPILE_CLASSPATH, used in call to javac.exe
if (CMAKE_HOST_WIN32)
        # The CMake list separator is ";" which is also what the Java
        # classpath uses, but we have to escape it twice to get through.
        STRING(REPLACE ";" "\\\;" COMPILE_CLASSPATH "${CLASSPATH_LIST}")
else()
        # On non-Windows platforms just convert the CMake list separator
        # ";" to the Java classpath list separator ":".
        STRING(REPLACE ";" ":" COMPILE_CLASSPATH "${CLASSPATH_LIST}")
endif()

# TODO: should we list the .java files separately instead of wildcard?
set(CMD_COMPILE_PARSER
        ${Java_JAVAC_EXECUTABLE}
                -cp
                ${COMPILE_CLASSPATH}
                ${my_grammar}*.java
)

# And then we compile the generated java to produce the class files.
add_custom_command(
        COMMAND ${CMD_COMPILE_PARSER}
        DEPENDS ${my_grammar}Parser.java ${my_grammar}Lexer.java
        OUTPUT
            ${my_grammar}Parser.class
            ${my_grammar}Lexer.class
        COMMENT "Running Java compiler to compile Java version of Lexer and Parser."
)

# Generate CMake variable TEST_RIG_INI_CLASSPATH for writing to test_rig.ini.
if (CMAKE_HOST_WIN32)
        # file() writes a list as "foo;bar" which happens to be what we want.
        # (Lack of quotes around ${CLASSPATH_LIST} intentional, here only.)
        SET(TEST_RIG_INI_CLASSPATH ${CLASSPATH_LIST})
else()
        # Non-Windows platforms we just need to write a : instead of ; here.
        STRING(REPLACE ";" ":" TEST_RIG_INI_CLASSPATH "${CLASSPATH_LIST}")
endif()

set(TEST_RIG_INI_MODE "-tree")
set(TEST_RIG_INI_INPUT "${PROJECT_SOURCE_DIR}/examples/example1.txt")
set(TEST_RIG_INI_ANTLR_CLASS "org.antlr.v4.gui.TestRig")

file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/test_rig.ini
"[Java Args]
javac_executable=${Java_JAVAC_EXECUTABLE}
java_executable=${Java_JAVA_EXECUTABLE}
classpath=${TEST_RIG_INI_CLASSPATH}
antlr_class=${TEST_RIG_INI_ANTLR_CLASS}
[ANTLR Args]
grammar_name=${my_grammar}
start_rule=${my_grammar_start_rule}
harness_mode=${TEST_RIG_INI_MODE}
input_file=${TEST_RIG_INI_INPUT}"
)

add_custom_target(
        grammar_in_java
        DEPENDS
            ${my_grammar}Parser.class
            ${my_grammar}Parser.class
        COMMENT "Generate and compile the grammar in Java form for test rig."
)

add_dependencies(test_rig grammar_in_java)